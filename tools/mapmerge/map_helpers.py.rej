diff a/tools/mapmerge/map_helpers.py b/tools/mapmerge/map_helpers.py	(rejected hunks)
@@ -1,5 +1,6 @@
 import sys
 import subprocess
+from datetime import datetime
 
 tgm_header = "//MAP CONVERTED BY dmm2tgm.py THIS HEADER COMMENT PREVENTS RECONVERSION, DO NOT REMOVE"
 
@@ -27,7 +28,7 @@ def merge_map(newfile, backupfile, tgm):
     if new_map["key_length"] != old_map["key_length"]:
         if tgm:
             write_dictionary_tgm(newfile, new_map["dictionary"])
-            write_grid_coord_small(newfile, new_map["grid"])
+            write_grid_coord_small(newfile, new_map["grid"], new_map["maxx"], new_map["maxy"])
         return 1
     else:
         key_length = old_map["key_length"]
@@ -35,7 +36,7 @@ def merge_map(newfile, backupfile, tgm):
     if new_map["maxx"] != old_map["maxx"] or new_map["maxy"] != old_map["maxy"]:
         if tgm:
             write_dictionary_tgm(newfile, new_map["dictionary"])
-            write_grid_coord_small(newfile, new_map["grid"])
+            write_grid_coord_small(newfile, new_map["grid"], new_map["maxx"], new_map["maxy"])
         return 2
     else:
         maxx = old_map["maxx"]
@@ -73,7 +74,10 @@ def merge_map(newfile, backupfile, tgm):
             if new_tile == old_tile: #this tile is the exact same as before, so the old key is used
                 merged_grid[x,y] = old_key
                 known_keys[new_key] = old_key
-                unused_keys.remove(old_key)
+                try:
+                    unused_keys.remove(old_key)
+                except ValueError as ve_exception:
+                    print("NOTICE: Correcting duplicate dictionary entry. ({})".format(new_key))
                 continue
 
             #the tile is different here, but if it exists in the old dictionary, its old key can be used
@@ -83,7 +87,7 @@ def merge_map(newfile, backupfile, tgm):
                 known_keys[new_key] = newold_key
                 try:
                     unused_keys.remove(newold_key)
-                except ValueError:
+                except ValueError as ve_exception:
                     print("NOTICE: Correcting duplicate dictionary entry. ({})".format(new_key))
 
             #the tile is brand new and it needs a new key, but if the old key isn't being used any longer it can be used instead
@@ -99,25 +103,32 @@ def merge_map(newfile, backupfile, tgm):
                 old_dict[fresh_key] = new_tile
                 merged_grid[x,y] = fresh_key
 
-##    #step two: clean the dictionary if it has too many unused keys
-##    if len(unused_keys) > min(100, (len(old_dict) * 0.5)):
-##        print("NOTICE: Trimming the dictionary.")
-##        old_dict = trim_dictionary(old_dict)
+    header = False
+    #step two: clean the dictionary if it has too many unused keys
+    if len(unused_keys) > min(1600, (len(old_dict) * 0.5)):
+        print("NOTICE: Trimming the dictionary.")
+        trimmed_dict_map = trim_dictionary({"dictionary": old_dict, "grid": merged_grid})
+        old_dict = trimmed_dict_map["dictionary"]
+        merged_grid = trimmed_dict_map["grid"]
+        print("NOTICE: Trimmed out {} unused dictionary keys.".format(len(unused_keys)))
+        header = "//Model dictionary trimmed on: {}".format(datetime.utcnow().strftime("%d-%m-%Y %H:%M (UTC)"))
 
     #step three: write the map to file
     if tgm:
-        write_dictionary_tgm(newfile, old_dict)
+        write_dictionary_tgm(newfile, old_dict, header)
         write_grid_coord_small(newfile, merged_grid, maxx, maxy)
     else:
-        write_dictionary(newfile, old_dict)
+        write_dictionary(newfile, old_dict, header)
         write_grid(newfile, merged_grid, maxx, maxy)
     return 0
 
 #######################
 #write to file helpers#
-def write_dictionary_tgm(filename, dictionary): #write dictionary in tgm format
+def write_dictionary_tgm(filename, dictionary, header = None): #write dictionary in tgm format
     with open(filename, "w") as output:
         output.write("{}\n".format(tgm_header))
+        if header:
+            output.write("{}\n".format(header))
         for key, list_ in dictionary.items():
             output.write("\"{}\" = (\n".format(key))
 
@@ -171,9 +182,11 @@ def write_grid_coord_small(filename, grid, maxx, maxy): #thanks to YotaXP for fi
             output.write("{}\n\"}}\n".format(grid[x,maxy]))
 
 
-def write_dictionary(filename, dictionary): #writes a tile dictionary the same way Dreammaker does
+def write_dictionary(filename, dictionary, header = None): #writes a tile dictionary the same way Dreammaker does
     with open(filename, "w") as output:
         for key, value in dictionary.items():
+            if header:
+                output.write("{}\n".format(header))
             output.write("\"{}\" = ({})\n".format(key, ",".join(value)))
 
 
@@ -194,26 +207,39 @@ def write_grid(filename, grid, maxx, maxy): #writes a map grid the same way Drea
 
 ####################
 #dictionary helpers#
+
+#faster than get_key() on smaller dictionaries
 def search_key(dictionary, data):
     for key, value in dictionary.items():
         if value == data:
             return key
     return None
 
-def get_key(keys, values, data):
+#faster than search_key() on bigger dictionaries
+def get_key(keys, values, data): 
     try:
         return keys[values.index(data)]
     except:
         return None
 
-def trim_dictionary(dictionary): #rewrites dictionary into an ordered dictionary with no unused keys
+def trim_dictionary(unclean_map): #rewrites dictionary into an ordered dictionary with no unused keys
     trimmed_dict = collections.OrderedDict()
-    key_length = len(list(dictionary.keys())[0])
+    adjusted_grid = dict()
+    key_length = len(list(unclean_map["dictionary"].keys())[0])
     key = ""
-    for tile in dictionary.values():
-        key = get_next_key(key, key_length)
-        trimmed_dict[key] = tile
-    return trimmed_dict
+    old_to_new = dict()
+    used_keys = set(unclean_map["grid"].values())
+
+    for old_key, tile in unclean_map["dictionary"].items():
+        if old_key in used_keys:
+            key = get_next_key(key, key_length)
+            trimmed_dict[key] = tile
+            old_to_new[old_key] = key
+
+    for coord, old_key in unclean_map["grid"].items():
+        adjusted_grid[coord] = old_to_new[old_key]
+
+    return {"dictionary": trimmed_dict, "grid": adjusted_grid}
 
 def sort_dictionary(dictionary):
     sorted_dict = collections.OrderedDict()
@@ -230,6 +256,9 @@ def get_map_raw_text(mapfile):
         return reading.read()
 
 def parse_map(map_raw_text): #still does not support more than one z level per file, but should parse any format
+    in_comment_line = False
+    comment_trigger = False
+
     in_quote_block = False
     in_key_block = False
     in_data_block = False
@@ -266,9 +295,26 @@ def parse_map(map_raw_text): #still does not support more than one z level per f
 
         if not in_map_block:
 
-            if char == "\n" or char == "\t":
+            if char == "\n":
+                in_comment_line = False
+                comment_trigger = False
                 continue
 
+            if in_comment_line:
+                continue
+
+            if char == "\t":
+                continue
+
+            if char == "/" and not in_quote_block:
+                if comment_trigger:
+                    in_comment_line = True
+                    continue
+                else:
+                    comment_trigger = True
+            else:
+                comment_trigger = False
+            
             if in_data_block:
 
                 if in_varedit_block:
