diff a/code/game/turfs/turf.dm b/code/game/turfs/turf.dm	(rejected hunks)
@@ -96,24 +96,14 @@
 
 	return FALSE
 
-/turf/CanPass(atom/movable/mover, turf/target, height=1.5)
+/turf/CanPass(atom/movable/mover, turf/target)
 	if(!target) return FALSE
 
 	if(istype(mover)) // turf/Enter(...) will perform more advanced checks
 		return !density
 
-	else // Now, doing more detailed checks for air movement and air group formation
-		if(target.blocks_air||blocks_air)
-			return FALSE
-
-		for(var/obj/obstacle in src)
-			if(!obstacle.CanPass(mover, target, height))
-				return FALSE
-		for(var/obj/obstacle in target)
-			if(!obstacle.CanPass(mover, src, height))
-				return FALSE
-
-		return TRUE
+	stack_trace("Non movable passed to turf CanPass : [mover]")
+	return FALSE
 
 /turf/Enter(atom/movable/mover as mob|obj, atom/forget as mob|obj|turf|area)
 	if (!mover)
@@ -123,22 +113,23 @@
 		// Nothing but border objects stop you from leaving a tile, only one loop is needed
 		for(var/obj/obstacle in mover.loc)
 			if(!obstacle.CheckExit(mover, src) && obstacle != mover && obstacle != forget)
-				mover.Bump(obstacle, 1)
+				mover.Collide(obstacle)
 				return FALSE
 
 	var/list/large_dense = list()
+	
 	//Next, check objects to block entry that are on the border
 	for(var/atom/movable/border_obstacle in src)
 		if(border_obstacle.flags & ON_BORDER)
 			if(!border_obstacle.CanPass(mover, mover.loc, 1) && (forget != border_obstacle))
-				mover.Bump(border_obstacle, 1)
+				mover.Collide(border_obstacle)
 				return FALSE
 		else
 			large_dense += border_obstacle
 
 	//Then, check the turf itself
 	if (!src.CanPass(mover, src))
-		mover.Bump(src, 1)
+		mover.Collide(src)
 		return FALSE
 
 	//Finally, check objects/mobs to block entry that are not on the border
@@ -150,7 +141,7 @@
 				tompost_bump = obstacle
 				top_layer = obstacle.layer
 	if(tompost_bump)
-		mover.Bump(tompost_bump,1)
+		mover.Collide(tompost_bump)
 		return FALSE
 
 	return TRUE //Nothing found to block so return success!
@@ -206,11 +197,11 @@
 		qdel(L)
 
 //wrapper for ChangeTurf()s that you want to prevent/affect without overriding ChangeTurf() itself
-/turf/proc/TerraformTurf(path, defer_change = FALSE, ignore_air = FALSE)
-	return ChangeTurf(path, defer_change, ignore_air)
+/turf/proc/TerraformTurf(path, new_baseturf, defer_change = FALSE, ignore_air = FALSE)
+	return ChangeTurf(path, new_baseturf, defer_change, ignore_air)
 
 //Creates a new turf
-/turf/proc/ChangeTurf(path, defer_change = FALSE, ignore_air = FALSE)
+/turf/proc/ChangeTurf(path, new_baseturf, defer_change = FALSE, ignore_air = FALSE)
 	if(!path)
 		return
 	if(!GLOB.use_preloader && path == type) // Don't no-op if the map loader requires it to be reconstructed
@@ -221,7 +212,10 @@
 	qdel(src)	//Just get the side effects and call Destroy
 	var/turf/W = new path(src)
 
-	W.baseturf = old_baseturf
+	if(new_baseturf)
+		W.baseturf = new_baseturf
+	else
+		W.baseturf = old_baseturf
 
 	if(!defer_change)
 		W.AfterChange(ignore_air)
@@ -232,10 +226,6 @@
 	levelupdate()
 	CalculateAdjacentTurfs()
 
-	if(!can_have_cabling())
-		for(var/obj/structure/cable/C in contents)
-			C.deconstruct()
-
 	//update firedoor adjacency
 	var/list/turfs_to_check = get_adjacent_open_turfs(src) | src
 	for(var/I in turfs_to_check)
@@ -417,25 +407,20 @@
 	if(!SSticker.HasRoundStarted())
 		add_blueprints(AM)
 
-/turf/proc/empty(turf_type=/turf/open/space)
+/turf/proc/empty(turf_type=/turf/open/space, baseturf_type)
 	// Remove all atoms except observers, landmarks, docking ports
-	var/turf/T0 = src
-	for(var/A in T0.GetAllContents())
-		if(istype(A, /mob/dead))
-			continue
-		if(istype(A, /obj/effect/landmark))
-			continue
-		if(istype(A, /obj/docking_port))
-			continue
-		if(A == T0)
-			continue
-		qdel(A, force=TRUE)
-
-	T0.ChangeTurf(turf_type)
-
-	SSair.remove_from_active(T0)
-	T0.CalculateAdjacentTurfs()
-	SSair.add_to_active(T0,1)
+	var/static/list/ignored_atoms = typecacheof(list(/mob/dead, /obj/effect/landmark, /obj/docking_port, /atom/movable/lighting_object))
+	var/list/allowed_contents = typecache_filter_list_reverse(GetAllContents(),ignored_atoms)
+	allowed_contents -= src
+	for(var/i in 1 to allowed_contents.len)
+		var/thing = allowed_contents[i]
+		qdel(thing, force=TRUE)
+
+	var/turf/newT = ChangeTurf(turf_type, baseturf_type, FALSE, FALSE)
+
+	SSair.remove_from_active(newT)
+	newT.CalculateAdjacentTurfs()
+	SSair.add_to_active(newT,1)
 
 /turf/proc/is_transition_turf()
 	return
