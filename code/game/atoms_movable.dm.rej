diff a/code/game/atoms_movable.dm b/code/game/atoms_movable.dm	(rejected hunks)
@@ -2,8 +2,8 @@
 	layer = OBJ_LAYER
 	var/last_move = null
 	var/anchored = 0
-	var/throwing = 0
-	var/throw_speed = 2
+	var/datum/thrownthing/throwing = null
+	var/throw_speed = 2 //How many tiles to move per ds when being thrown. Float values are fully supported
 	var/throw_range = 7
 	var/mob/pulledby = null
 	var/languages_spoken = 0 //For say() and Hear()
@@ -20,10 +20,20 @@
 	var/pass_flags = 0
 	var/moving_diagonally = 0 //0: not doing a diagonal move. 1 and 2: doing the first/second step of the diagonal move
 	var/list/client_mobs_in_contents // This contains all the client mobs within this container
+	var/list/acted_explosions	//for explosion dodging
 	glide_size = 8
 	appearance_flags = TILE_BOUND
-
-
+	var/datum/forced_movement/force_moving = null	//handled soley by forced_movement.dm
+	var/floating = FALSE
+
+/atom/movable/vv_edit_var(var_name, var_value)
+	var/static/list/banned_edits = list("step_x", "step_y", "step_size")
+	var/static/list/careful_edits = list("bound_x", "bound_y", "bound_width", "bound_height")
+	if(var_name in banned_edits)
+		return FALSE	//PLEASE no.
+	if((var_name in careful_edits) && (var_value % world.icon_size) != 0)
+		return FALSE
+	return ..()
 
 /atom/movable/Move(atom/newloc, direct = 0)
 	if(!loc || !newloc) return 0
@@ -86,14 +96,70 @@
 		newtonian_move(Dir)
 	if (length(client_mobs_in_contents))
 		update_parallax_contents()
+
+	if (orbiters)
+		for (var/thing in orbiters)
+			var/datum/orbit/O = thing
+			O.Check()
+	if (orbiting)
+		orbiting.Check()
+
+	if(flags & CLEAN_ON_MOVE)
+		clean_on_move()
 	return 1
 
-/atom/movable/Destroy()
+/atom/movable/proc/clean_on_move()
+	var/turf/tile = loc
+	if(isturf(tile))
+		tile.clean_blood()
+		for(var/A in tile)
+			if(is_cleanable(A))
+				qdel(A)
+			else if(istype(A, /obj/item))
+				var/obj/item/cleaned_item = A
+				cleaned_item.clean_blood()
+			else if(ishuman(A))
+				var/mob/living/carbon/human/cleaned_human = A
+				if(cleaned_human.lying)
+					if(cleaned_human.head)
+						cleaned_human.head.clean_blood()
+						cleaned_human.update_inv_head()
+					if(cleaned_human.wear_suit)
+						cleaned_human.wear_suit.clean_blood()
+						cleaned_human.update_inv_wear_suit()
+					else if(cleaned_human.w_uniform)
+						cleaned_human.w_uniform.clean_blood()
+						cleaned_human.update_inv_w_uniform()
+					if(cleaned_human.shoes)
+						cleaned_human.shoes.clean_blood()
+						cleaned_human.update_inv_shoes()
+					cleaned_human.clean_blood()
+					cleaned_human.wash_cream()
+					to_chat(cleaned_human, "<span class='danger'>[src] cleans your face!</span>")
+
+/atom/movable/Destroy(force)
+	var/inform_admins = HAS_SECONDARY_FLAG(src, INFORM_ADMINS_ON_RELOCATE)
+	var/stationloving = HAS_SECONDARY_FLAG(src, STATIONLOVING)
+
+	if(inform_admins && force)
+		var/turf/T = get_turf(src)
+		message_admins("[src] has been !!force deleted!! in [ADMIN_COORDJMP(T)].")
+		log_game("[src] has been !!force deleted!! in [COORD(T)].")
+
+	if(stationloving && !force)
+		var/turf/currentturf = get_turf(src)
+		var/turf/targetturf = relocate()
+		log_game("[src] has been destroyed in [COORD(currentturf)]. Moving it to [COORD(targetturf)].")
+		if(inform_admins)
+			message_admins("[src] has been destroyed in [ADMIN_COORDJMP(currentturf)]. Moving it to [ADMIN_COORDJMP(targetturf)].")
+		return QDEL_HINT_LETMELIVE
+
+	if(stationloving && force)
+		STOP_PROCESSING(SSinbounds, src)
+
 	. = ..()
 	if(loc)
 		loc.handle_atom_del(src)
-	if(reagents)
-		qdel(reagents)
 	for(var/atom/movable/AM in contents)
 		qdel(AM)
 	loc = null
@@ -110,31 +176,38 @@
 /atom/movable/Bump(atom/A, yes) //the "yes" arg is to differentiate our Bump proc from byond's, without it every Bump() call would become a double Bump().
 	if((A && yes))
 		if(throwing)
-			throwing = 0
-			throw_impact(A)
+			throwing.hit_atom(A)
 			. = 1
-			if(!A || qdeleted(A))
+			if(!A || QDELETED(A))
 				return
 		A.Bumped(src)
 
-
 /atom/movable/proc/forceMove(atom/destination)
 	if(destination)
 		if(pulledby)
 			pulledby.stop_pulling()
 		var/atom/oldloc = loc
-		if(oldloc)
-			oldloc.Exited(src, destination)
-		loc = destination
-		destination.Entered(src, oldloc)
+		var/same_loc = oldloc == destination
 		var/area/old_area = get_area(oldloc)
 		var/area/destarea = get_area(destination)
-		if(old_area != destarea)
-			destarea.Entered(src)
-		for(var/atom/movable/AM in destination)
-			if(AM == src)
-				continue
-			AM.Crossed(src)
+
+		if(oldloc && !same_loc)
+			oldloc.Exited(src, destination)
+			if(old_area)
+				old_area.Exited(src, destination)
+
+		loc = destination
+
+		if(!same_loc)
+			destination.Entered(src, oldloc)
+			if(destarea && old_area != destarea)
+				destarea.Entered(src, oldloc)
+
+			for(var/atom/movable/AM in destination)
+				if(AM == src)
+					continue
+				AM.Crossed(src)
+
 		Moved(oldloc, 0)
 		return 1
 	return 0
@@ -192,7 +265,7 @@
 /atom/movable/proc/checkpass(passflag)
 	return pass_flags&passflag
 
-/atom/movable/proc/throw_impact(atom/hit_atom)
+/atom/movable/proc/throw_impact(atom/hit_atom, throwingdatum)
 	return hit_atom.hitby(src)
 
 /atom/movable/hitby(atom/movable/AM, skipcatch, hitpush = 1, blocked)
@@ -200,109 +273,82 @@
 		step(src, AM.dir)
 	..()
 
-/atom/movable/proc/throw_at_fast(atom/target, range, speed, mob/thrower, spin=1, diagonals_first = 0)
-	set waitfor = 0
-	throw_at(target, range, speed, thrower, spin, diagonals_first)
-
-/atom/movable/proc/throw_at(atom/target, range, speed, mob/thrower, spin=1, diagonals_first = 0)
-	if(!target || !src || (flags & NODROP))
-		return 0
-	//use a modified version of Bresenham's algorithm to get from the atom's current position to that of the target
+/atom/movable/proc/throw_at(atom/target, range, speed, mob/thrower, spin=TRUE, diagonals_first = FALSE, var/datum/callback/callback)
+	if (!target || (flags & NODROP) || speed <= 0)
+		return
 
-	if(pulledby)
+	if (pulledby)
 		pulledby.stop_pulling()
 
-	throwing = 1
-	if(spin) //if we don't want the /atom/movable to spin.
-		SpinAnimation(5, 1)
+	//They are moving! Wouldn't it be cool if we calculated their momentum and added it to the throw?
+	if (thrower && thrower.last_move && thrower.client && thrower.client.move_delay >= world.time + world.tick_lag*2)
+		var/user_momentum = thrower.movement_delay()
+		if (!user_momentum) //no movement_delay, this means they move once per byond tick, lets calculate from that instead.
+			user_momentum = world.tick_lag
 
-	var/dist_travelled = 0
-	var/next_sleep = 0
+		user_momentum = 1 / user_momentum // convert from ds to the tiles per ds that throw_at uses.
+
+		if (get_dir(thrower, target) & last_move)
+			user_momentum = user_momentum //basically a noop, but needed
+		else if (get_dir(target, thrower) & last_move)
+			user_momentum = -user_momentum //we are moving away from the target, lets slowdown the throw accordingly
+		else
+			user_momentum = 0
+
+
+		if (user_momentum)
+			//first lets add that momentum to range.
+			range *= (user_momentum / speed) + 1
+			//then lets add it to speed
+			speed += user_momentum
+			if (speed <= 0)
+				return //no throw speed, the user was moving too fast.
+
+	var/datum/thrownthing/TT = new()
+	TT.thrownthing = src
+	TT.target = target
+	TT.target_turf = get_turf(target)
+	TT.init_dir = get_dir(src, target)
+	TT.maxrange = range
+	TT.speed = speed
+	TT.thrower = thrower
+	TT.diagonals_first = diagonals_first
+	TT.callback = callback
 
 	var/dist_x = abs(target.x - src.x)
 	var/dist_y = abs(target.y - src.y)
 	var/dx = (target.x > src.x) ? EAST : WEST
 	var/dy = (target.y > src.y) ? NORTH : SOUTH
 
-	var/pure_diagonal = 0
-	if(dist_x == dist_y)
-		pure_diagonal = 1
+	if (dist_x == dist_y)
+		TT.pure_diagonal = 1
 
-	if(dist_x <= dist_y)
+	else if(dist_x <= dist_y)
 		var/olddist_x = dist_x
 		var/olddx = dx
 		dist_x = dist_y
 		dist_y = olddist_x
 		dx = dy
 		dy = olddx
+	TT.dist_x = dist_x
+	TT.dist_y = dist_y
+	TT.dx = dx
+	TT.dy = dy
+	TT.diagonal_error = dist_x/2 - dist_y
+	TT.start_time = world.time
 
-	var/error = dist_x/2 - dist_y //used to decide whether our next move should be forward or diagonal.
-	var/atom/finalturf = get_turf(target)
-	var/hit = 0
-	var/init_dir = get_dir(src, target)
+	if(pulledby)
+		pulledby.stop_pulling()
 
-	while(target && ((dist_travelled < range && loc != finalturf)  || !has_gravity(src))) //stop if we reached our destination (or max range) and aren't floating
-		var/slept = 0
-		if(!isturf(loc))
-			hit = 1
-			break
+	throwing = TT
+	if(spin)
+		SpinAnimation(5, 1)
 
-		var/atom/step
-		if(dist_travelled < max(dist_x, dist_y)) //if we haven't reached the target yet we home in on it, otherwise we use the initial direction
-			step = get_step(src, get_dir(src, finalturf))
-		else
-			step = get_step(src, init_dir)
-
-		if(!pure_diagonal && !diagonals_first) // not a purely diagonal trajectory and we don't want all diagonal moves to be done first
-			if(error >= 0 && max(dist_x,dist_y) - dist_travelled != 1) //we do a step forward unless we're right before the target
-				step = get_step(src, dx)
-			error += (error < 0) ? dist_x/2 : -dist_y
-		if(!step) // going off the edge of the map makes get_step return null, don't let things go off the edge
-			break
-		Move(step, get_dir(loc, step))
-		if(!throwing) // we hit something during our move
-			hit = 1
-			break
-		dist_travelled++
-
-		if(dist_travelled > 600) //safety to prevent infinite while loop.
-			break
-		if(dist_travelled >= next_sleep)
-			slept = 1
-			next_sleep += speed
-			sleep(1)
-		if(!slept)
-			var/ticks_slept = TICK_CHECK
-			if(ticks_slept)
-				slept = 1
-				next_sleep += speed*(ticks_slept*world.tick_lag) //delay the next normal sleep
-
-		if(slept && hitcheck()) //to catch sneaky things moving on our tile while we slept
-			hit = 1
-			break
-
-
-	//done throwing, either because it hit something or it finished moving
-	throwing = 0
-	if(!hit)
-		for(var/atom/A in get_turf(src)) //looking for our target on the turf we land on.
-			if(A == target)
-				hit = 1
-				throw_impact(A)
-				return 1
-
-		throw_impact(get_turf(src))  // we haven't hit something yet and we still must, let's hit the ground.
-	newtonian_move(init_dir)
-	return 1
+	SSthrowing.processing[src] = TT
+	if (SSthrowing.state == SS_PAUSED && length(SSthrowing.currentrun))
+		SSthrowing.currentrun[src] = TT
+	TT.tick()
 
-/atom/movable/proc/hitcheck()
-	for(var/atom/movable/AM in get_turf(src))
-		if(AM == src)
-			continue
-		if(AM.density && !(AM.pass_flags & LETPASSTHROW) && !(AM.flags & ON_BORDER))
-			throwing = 0
-			throw_impact(AM)
-			return 1
 
 /atom/movable/proc/handle_buckled_mob_movement(newloc,direct)
 	for(var/m in buckled_mobs)
@@ -408,3 +454,99 @@
 	. = ..()
 	. -= "Jump to"
 	.["Follow"] = "?_src_=holder;adminplayerobservefollow=\ref[src]"
+
+/atom/movable/proc/ex_check(ex_id)
+	if(!ex_id)
+		return TRUE
+	LAZYINITLIST(acted_explosions)
+	if(ex_id in acted_explosions)
+		return FALSE
+	acted_explosions += ex_id
+	return TRUE
+
+/atom/movable/proc/float(on)
+	if(throwing)
+		return
+	if(on && !floating)
+		animate(src, pixel_y = pixel_y + 2, time = 10, loop = -1)
+		sleep(10)
+		animate(src, pixel_y = pixel_y - 2, time = 10, loop = -1)
+		floating = TRUE
+	else if (!on && floating)
+		animate(src, pixel_y = initial(pixel_y), time = 10)
+		floating = FALSE
+
+/* Stationloving
+*
+* A stationloving atom will always teleport back to the station
+* if it ever leaves the station z-levels or Centcom. It will also,
+* when Destroy() is called, will teleport to a random turf on the
+* station.
+*
+* The turf is guaranteed to be "safe" for normal humans, probably.
+* If the station is SUPER SMASHED UP, it might not work.
+*
+* Here are some important procs:
+* relocate()
+* moves the atom to a safe turf on the station
+*
+* check_in_bounds()
+* regularly called and checks if `in_bounds()` returns true. If false, it
+* triggers a `relocate()`.
+*
+* in_bounds()
+* By default, checks that the atom's z is the station z or centcom.
+*/
+
+/atom/movable/proc/set_stationloving(state, inform_admins=FALSE)
+	var/currently = HAS_SECONDARY_FLAG(src, STATIONLOVING)
+
+	if(inform_admins)
+		SET_SECONDARY_FLAG(src, INFORM_ADMINS_ON_RELOCATE)
+	else
+		CLEAR_SECONDARY_FLAG(src, INFORM_ADMINS_ON_RELOCATE)
+
+	if(state == currently)
+		return
+	else if(!state)
+		STOP_PROCESSING(SSinbounds, src)
+		CLEAR_SECONDARY_FLAG(src, STATIONLOVING)
+	else
+		START_PROCESSING(SSinbounds, src)
+		SET_SECONDARY_FLAG(src, STATIONLOVING)
+
+/atom/movable/proc/relocate()
+	var/targetturf = find_safe_turf(ZLEVEL_STATION)
+	if(!targetturf)
+		if(blobstart.len > 0)
+			targetturf = get_turf(pick(blobstart))
+		else
+			throw EXCEPTION("Unable to find a blobstart landmark")
+
+	if(ismob(loc))
+		var/mob/M = loc
+		M.transferItemToLoc(src, targetturf, TRUE)	//nodrops disks when?
+	else if(istype(loc, /obj/item/weapon/storage))
+		var/obj/item/weapon/storage/S = loc
+		S.remove_from_storage(src, targetturf)
+	else
+		forceMove(targetturf)
+	// move the disc, so ghosts remain orbiting it even if it's "destroyed"
+	return targetturf
+
+/atom/movable/proc/check_in_bounds()
+	if(in_bounds())
+		return
+	else
+		var/turf/currentturf = get_turf(src)
+		get(src, /mob) << "<span class='danger'>You can't help but feel that you just lost something back there...</span>"
+		var/turf/targetturf = relocate()
+		log_game("[src] has been moved out of bounds in [COORD(currentturf)]. Moving it to [COORD(targetturf)].")
+		if(HAS_SECONDARY_FLAG(src, INFORM_ADMINS_ON_RELOCATE))
+			message_admins("[src] has been moved out of bounds in [ADMIN_COORDJMP(currentturf)]. Moving it to [ADMIN_COORDJMP(targetturf)].")
+
+/atom/movable/proc/in_bounds()
+	. = FALSE
+	var/turf/currentturf = get_turf(src)
+	if(currentturf && (currentturf.z == ZLEVEL_CENTCOM || currentturf.z == ZLEVEL_STATION))
+		. = TRUE
