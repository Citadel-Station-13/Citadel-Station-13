diff a/code/datums/beam.dm b/code/datums/beam.dm	(rejected hunks)
@@ -7,17 +7,16 @@
 	var/icon
 	var/icon_state = "" //icon state of the main segments of the beam
 	var/max_distance = 0
-	var/endtime = 0
 	var/sleep_time = 3
 	var/finished = 0
 	var/target_oldloc = null
 	var/origin_oldloc = null
 	var/static_beam = 0
 	var/beam_type = /obj/effect/ebeam //must be subtype
-
+	var/timing_id = null
+	var/recalculating = FALSE
 
 /datum/beam/New(beam_origin,beam_target,beam_icon='icons/effects/beam.dmi',beam_icon_state="b_beam",time=50,maxdistance=10,btype = /obj/effect/ebeam,beam_sleep_time=3)
-	endtime = world.time+time
 	origin = beam_origin
 	origin_oldloc =	get_turf(origin)
 	target = beam_target
@@ -30,11 +29,19 @@
 	icon = beam_icon
 	icon_state = beam_icon_state
 	beam_type = btype
-
+	addtimer(CALLBACK(src,.proc/End), time)
 
 /datum/beam/proc/Start()
 	Draw()
-	while(!finished && origin && target && world.time < endtime && get_dist(origin,target)<max_distance && origin.z == target.z)
+	recalculate_in(sleep_time)
+
+/datum/beam/proc/recalculate()
+	if(recalculating)
+		recalculate_in(sleep_time)
+		return
+	recalculating = TRUE
+	timing_id = null
+	if(origin && target && get_dist(origin,target)<max_distance && origin.z == target.z)
 		var/origin_turf = get_turf(origin)
 		var/target_turf = get_turf(target)
 		if(!static_beam && (origin_turf != origin_oldloc || target_turf != target_oldloc))
@@ -42,30 +49,44 @@
 			target_oldloc = target_turf
 			Reset()
 			Draw()
-		sleep(sleep_time)
-
-	qdel(src)
-
-
-/datum/beam/proc/End()
-	finished = 1
-
+		after_calculate()
+		recalculating = FALSE
+	else
+		End()
+
+/datum/beam/proc/afterDraw()
+	return
+
+/datum/beam/proc/recalculate_in(time)
+	if(timing_id)
+		deltimer(timing_id)
+	timing_id = addtimer(CALLBACK(src, .proc/recalculate), time, TIMER_STOPPABLE)
+
+/datum/beam/proc/after_calculate()
+	if((sleep_time == null) || finished)	//Does not automatically recalculate.
+		return
+	if(isnull(timing_id))
+		timing_id = addtimer(CALLBACK(src, .proc/recalculate), sleep_time, TIMER_STOPPABLE)
+
+/datum/beam/proc/End(destroy_self = TRUE)
+	finished = TRUE
+	if(!isnull(timing_id))
+		deltimer(timing_id)
+	if(!QDELETED(src) && destroy_self)
+		qdel(src)
 
 /datum/beam/proc/Reset()
 	for(var/obj/effect/ebeam/B in elements)
 		qdel(B)
 
-
 /datum/beam/Destroy()
 	Reset()
 	target = null
 	origin = null
 	return ..()
 
-
 /datum/beam/proc/Draw()
 	var/Angle = round(Get_Angle(origin,target))
-
 	var/matrix/rot_matrix = matrix()
 	rot_matrix.Turn(Angle)
 
@@ -116,22 +137,18 @@
 		X.pixel_x = Pixel_x
 		X.pixel_y = Pixel_y
 		CHECK_TICK
-
+	afterDraw()
 
 /obj/effect/ebeam
 	mouse_opacity = 0
 	anchored = 1
 	var/datum/beam/owner
 
-
 /obj/effect/ebeam/Destroy()
 	owner = null
 	return ..()
 
-
 /atom/proc/Beam(atom/BeamTarget,icon_state="b_beam",icon='icons/effects/beam.dmi',time=50, maxdistance=10,beam_type=/obj/effect/ebeam,beam_sleep_time = 3)
 	var/datum/beam/newbeam = new(src,BeamTarget,icon,icon_state,time,maxdistance,beam_type,beam_sleep_time)
-	spawn(0)
-		newbeam.Start()
+	INVOKE_ASYNC(newbeam, /datum/beam/.proc/Start)
 	return newbeam
-
