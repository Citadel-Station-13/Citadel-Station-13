diff a/code/modules/mob/living/silicon/robot/inventory.dm b/code/modules/mob/living/silicon/robot/inventory.dm	(rejected hunks)
@@ -7,7 +7,7 @@
 
 
 
-/*-------TODOOOOOOOOOO--------*/
+/*-------TODOOOOOOOOOO--------*/ //fuck yooooooooooooou
 /mob/living/silicon/robot/proc/uneq_module(obj/item/O)
 	if(!O)
 		return 0
@@ -22,68 +22,59 @@
 	if(client)
 		client.screen -= O
 	observer_screen_update(O,FALSE)
-	contents -= O
-	if(module)
-		O.loc = module	//Return item to module so it appears in its contents, so it can be taken out again.
+	O.forceMove(module) //Return item to module so it appears in its contents, so it can be taken out again.
+
+	if(DROPDEL & O.flags)
+		O.flags &= ~DROPDEL //we shouldn't HAVE things with DROPDEL in our modules, but better safe than runtiming horribly
+
+	O.dropped(src)
 
 	if(module_active == O)
 		module_active = null
-	if(module_state_1 == O)
+	if(held_items[1] == O)
 		inv1.icon_state = "inv1"
-		module_state_1 = null
-	else if(module_state_2 == O)
+		held_items[1] = null
+	else if(held_items[2] == O)
 		inv2.icon_state = "inv2"
-		module_state_2 = null
-	else if(module_state_3 == O)
-		module_state_3 = null
+		held_items[2] = null
+	else if(held_items[3] == O)
 		inv3.icon_state = "inv3"
+		held_items[3] = null
 	hud_used.update_robot_modules_display()
 	return 1
 
 /mob/living/silicon/robot/proc/activate_module(obj/item/O)
-	if(!(locate(O) in src.module.modules) && O != src.module.emag)
+	. = FALSE
+	if(!(O in module.modules))
 		return
 	if(activated(O))
-		src << "<span class='notice'>Already activated</span>"
+		src << "<span class='warning'>That module is already activated.</span>"
 		return
-	if(!module_state_1)
-		O.mouse_opacity = initial(O.mouse_opacity)
-		module_state_1 = O
-		O.layer = ABOVE_HUD_LAYER
-		O.plane = ABOVE_HUD_PLANE
+	if(!held_items[1])
+		held_items[1] = O
 		O.screen_loc = inv1.screen_loc
-		observer_screen_update(O,TRUE)
-		contents += O
-		if(istype(module_state_1,/obj/item/borg/sight))
-			var/obj/item/borg/sight/S = module_state_1
-			sight_mode |= S.sight_mode
-			update_sight()
-	else if(!module_state_2)
-		O.mouse_opacity = initial(O.mouse_opacity)
-		module_state_2 = O
-		O.layer = ABOVE_HUD_LAYER
-		O.plane = ABOVE_HUD_PLANE
+		. = TRUE
+	else if(!held_items[2])
+		held_items[2] = O
 		O.screen_loc = inv2.screen_loc
-		observer_screen_update(O,TRUE)
-		contents += O
-		if(istype(module_state_2,/obj/item/borg/sight))
-			var/obj/item/borg/sight/S = module_state_2
-			sight_mode |= S.sight_mode
-			update_sight()
-	else if(!module_state_3)
+		. = TRUE
+	else if(!held_items[3])
+		held_items[3] = O
+		O.screen_loc = inv3.screen_loc
+		. = TRUE
+	else
+		src << "<span class='warning'>You need to disable a module first!</span>"
+	if(.)
+		O.equipped(src, slot_hands)
 		O.mouse_opacity = initial(O.mouse_opacity)
-		module_state_3 = O
 		O.layer = ABOVE_HUD_LAYER
 		O.plane = ABOVE_HUD_PLANE
-		O.screen_loc = inv3.screen_loc
 		observer_screen_update(O,TRUE)
-		contents += O
-		if(istype(module_state_3,/obj/item/borg/sight))
-			var/obj/item/borg/sight/S = module_state_3
+		O.forceMove(src)
+		if(istype(O, /obj/item/borg/sight))
+			var/obj/item/borg/sight/S = O
 			sight_mode |= S.sight_mode
 			update_sight()
-	else
-		src << "<span class='warning'>You need to disable a module first!</span>"
 
 
 /mob/living/silicon/robot/proc/observer_screen_update(obj/item/I,add = TRUE)
@@ -105,19 +96,13 @@
 	uneq_module(module_active)
 
 /mob/living/silicon/robot/proc/uneq_all()
-	uneq_module(module_state_1)
-	uneq_module(module_state_2)
-	uneq_module(module_state_3)
+	for(var/obj/item/I in held_items)
+		uneq_module(I)
 
 /mob/living/silicon/robot/proc/activated(obj/item/O)
-	if(module_state_1 == O)
-		return 1
-	else if(module_state_2 == O)
-		return 1
-	else if(module_state_3 == O)
-		return 1
-	else
-		return 0
+	if(O in held_items)
+		return TRUE
+	return FALSE
 
 //Helper procs for cyborg modules on the UI.
 //These are hackish but they help clean up code elsewhere.
@@ -128,82 +113,66 @@
 
 //module_active(module) - Checks whether there is a module active in the slot specified by "module".
 /mob/living/silicon/robot/proc/module_active(module) //Module is 1-3
-	if(module < 1 || module > 3) return 0
+	if(module < 1 || module > 3)
+		return FALSE
 
-	switch(module)
-		if(1)
-			if(module_state_1)
-				return 1
-		if(2)
-			if(module_state_2)
-				return 1
-		if(3)
-			if(module_state_3)
-				return 1
-	return 0
+	if(LAZYLEN(held_items) >= module)
+		if(held_items[module])
+			return TRUE
+	return FALSE
 
 //get_selected_module() - Returns the slot number of the currently selected module.  Returns 0 if no modules are selected.
 /mob/living/silicon/robot/proc/get_selected_module()
-	if(module_state_1 && module_active == module_state_1)
-		return 1
-	else if(module_state_2 && module_active == module_state_2)
-		return 2
-	else if(module_state_3 && module_active == module_state_3)
-		return 3
+	if(module_active)
+		return held_items.Find(module_active)
 
 	return 0
 
 //select_module(module) - Selects the module slot specified by "module"
 /mob/living/silicon/robot/proc/select_module(module) //Module is 1-3
-	if(module < 1 || module > 3) return
+	if(module < 1 || module > 3)
+		return
 
-	if(!module_active(module)) return
+	if(!module_active(module))
+		return
 
 	switch(module)
 		if(1)
-			if(module_active != module_state_1)
+			if(module_active != held_items[module])
 				inv1.icon_state = "inv1 +a"
 				inv2.icon_state = "inv2"
 				inv3.icon_state = "inv3"
-				module_active = module_state_1
-				return
 		if(2)
-			if(module_active != module_state_2)
+			if(module_active != held_items[module])
 				inv1.icon_state = "inv1"
 				inv2.icon_state = "inv2 +a"
 				inv3.icon_state = "inv3"
-				module_active = module_state_2
-				return
 		if(3)
-			if(module_active != module_state_3)
+			if(module_active != held_items[module])
 				inv1.icon_state = "inv1"
 				inv2.icon_state = "inv2"
 				inv3.icon_state = "inv3 +a"
-				module_active = module_state_3
-				return
-	return
+	module_active = held_items[module]
 
 //deselect_module(module) - Deselects the module slot specified by "module"
 /mob/living/silicon/robot/proc/deselect_module(module) //Module is 1-3
-	if(module < 1 || module > 3) return
+	if(module < 1 || module > 3)
+		return
+
+	if(!module_active(module))
+		return
 
 	switch(module)
 		if(1)
-			if(module_active == module_state_1)
+			if(module_active == held_items[module])
 				inv1.icon_state = "inv1"
-				module_active = null
-				return
 		if(2)
-			if(module_active == module_state_2)
+			if(module_active == held_items[module])
 				inv2.icon_state = "inv2"
-				module_active = null
-				return
 		if(3)
-			if(module_active == module_state_3)
+			if(module_active == held_items[module])
 				inv3.icon_state = "inv3"
-				module_active = null
-				return
-	return
+	module_active = null
 
 //toggle_module(module) - Toggles the selection of the module slot specified by "module".
 /mob/living/silicon/robot/proc/toggle_module(module) //Module is 1-3
